
## Overview
You are a code assistant that accepts a python test file, and a python included files.
Your goal is to generate one and only one additional unit test to complement the existing test suite, 
in order to increase the code coverage against the source file.

## Test File
Here is the test file that you will be writing tests against, called `args.go`.
=========
// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
	"fmt"
	"strings"
)

type PositionalArgs func(cmd *Command, args []string) error

// legacyArgs validation has the following behaviour:
// - root commands with no subcommands can take arbitrary arguments
// - root commands with subcommands will do subcommand validity checking
// - subcommands will always accept arbitrary arguments
func legacyArgs(cmd *Command, args []string) error {
	// no subcommand, always take args
	if !cmd.HasSubCommands() {
		return nil
	}

	// root command with subcommands, do subcommand checking.
	if !cmd.HasParent() && len(args) > 0 {
		return fmt.Errorf("unknown command %q for %q%s", args[0], cmd.CommandPath(), cmd.findSuggestions(args[0]))
	}
	return nil
}

// NoArgs returns an error if any args are included.
func NoArgs(cmd *Command, args []string) error {
	if len(args) > 0 {
		return fmt.Errorf("unknown command %q for %q", args[0], cmd.CommandPath())
	}
	return nil
}

// OnlyValidArgs returns an error if there are any positional args that are not in
// the `ValidArgs` field of `Command`
func OnlyValidArgs(cmd *Command, args []string) error {
	if len(cmd.ValidArgs) > 0 {
		// Remove any description that may be included in ValidArgs.
		// A description is following a tab character.
		validArgs := make([]string, 0, len(cmd.ValidArgs))
		for _, v := range cmd.ValidArgs {
			validArgs = append(validArgs, strings.SplitN(v, "\t", 2)[0])
		}
		for _, v := range args {
			if !stringInSlice(v, validArgs) {
				return fmt.Errorf("invalid argument %q for %q%s", v, cmd.CommandPath(), cmd.findSuggestions(args[0]))
			}
		}
	}
	return nil
}

// ArbitraryArgs never returns an error.
func ArbitraryArgs(cmd *Command, args []string) error {
	return nil
}

// MinimumNArgs returns an error if there is not at least N args.
func MinimumNArgs(n int) PositionalArgs {
	return func(cmd *Command, args []string) error {
		if len(args) < n {
			return fmt.Errorf("requires at least %d arg(s), only received %d", n, len(args))
		}
		return nil
	}
}

// MaximumNArgs returns an error if there are more than N args.
func MaximumNArgs(n int) PositionalArgs {
	return func(cmd *Command, args []string) error {
		if len(args) > n {
			return fmt.Errorf("accepts at most %d arg(s), received %d", n, len(args))
		}
		return nil
	}
}

// ExactArgs returns an error if there are not exactly n args.
func ExactArgs(n int) PositionalArgs {
	return func(cmd *Command, args []string) error {
		if len(args) != n {
			return fmt.Errorf("accepts %d arg(s), received %d", n, len(args))
		}
		return nil
	}
}

// RangeArgs returns an error if the number of args is not within the expected range.
func RangeArgs(min int, max int) PositionalArgs {
	return func(cmd *Command, args []string) error {
		if len(args) < min || len(args) > max {
			return fmt.Errorf("accepts between %d and %d arg(s), received %d", min, max, len(args))
		}
		return nil
	}
}

// MatchAll allows combining several PositionalArgs to work in concert.
func MatchAll(pargs ...PositionalArgs) PositionalArgs {
	return func(cmd *Command, args []string) error {
		for _, parg := range pargs {
			if err := parg(cmd, args); err != nil {
				return err
			}
		}
		return nil
	}
}

// ExactValidArgs returns an error if there are not exactly N positional args OR
// there are any positional args that are not in the `ValidArgs` field of `Command`
//
// Deprecated: use MatchAll(ExactArgs(n), OnlyValidArgs) instead
func ExactValidArgs(n int) PositionalArgs {
	return MatchAll(ExactArgs(n), OnlyValidArgs)
}

=========

## Included Files
Here are the included files that you will be writing tests against.
Note that we have manually added line numbers for each line of code, to help you understand increasing code coverage.
Those numbers are not a part of the original code.

FILE NAME : command.go =====
1 // Copyright 2013-2023 The Cobra Authors
2 //
3 // Licensed under the Apache License, Version 2.0 (the "License");
4 // you may not use this file except in compliance with the License.
5 // You may obtain a copy of the License at
6 //
7 //      http://www.apache.org/licenses/LICENSE-2.0
8 //
9 // Unless required by applicable law or agreed to in writing, software
10 // distributed under the License is distributed on an "AS IS" BASIS,
11 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12 // See the License for the specific language governing permissions and
13 // limitations under the License.
14 
15 // Package cobra is a commander providing a simple interface to create powerful modern CLI interfaces.
16 // In addition to providing an interface, Cobra simultaneously provides a controller to organize your application code.
17 package cobra
18 
19 import (
20 	"bytes"
21 	"context"
22 	"errors"
23 	"fmt"
24 	"io"
25 	"os"
26 	"path/filepath"
27 	"sort"
28 	"strings"
29 
30 	flag "github.com/spf13/pflag"
31 )
32 
33 const (
34 	FlagSetByCobraAnnotation     = "cobra_annotation_flag_set_by_cobra"
35 	CommandDisplayNameAnnotation = "cobra_annotation_command_display_name"
36 )
37 
38 // FParseErrWhitelist configures Flag parse errors to be ignored
39 type FParseErrWhitelist flag.ParseErrorsWhitelist
40 
41 // Group Structure to manage groups for commands
42 type Group struct {
43 	ID    string
44 	Title string
45 }
46 
47 // Command is just that, a command for your application.
48 // E.g.  'go run ...' - 'run' is the command. Cobra requires
49 // you to define the usage and description as part of your command
50 // definition to ensure usability.
51 type Command struct {
52 	// Use is the one-line usage message.
53 	// Recommended syntax is as follows:
54 	//   [ ] identifies an optional argument. Arguments that are not enclosed in brackets are required.
55 	//   ... indicates that you can specify multiple values for the previous argument.
56 	//   |   indicates mutually exclusive information. You can use the argument to the left of the separator or the
57 	//       argument to the right of the separator. You cannot use both arguments in a single use of the command.
58 	//   { } delimits a set of mutually exclusive arguments when one of the arguments is required. If the arguments are
59 	//       optional, they are enclosed in brackets ([ ]).
60 	// Example: add [-F file | -D dir]... [-f format] profile
61 	Use string
62 
63 	// Aliases is an array of aliases that can be used instead of the first word in Use.
64 	Aliases []string
65 
66 	// SuggestFor is an array of command names for which this command will be suggested -
67 	// similar to aliases but only suggests.
68 	SuggestFor []string
69 
70 	// Short is the short description shown in the 'help' output.
71 	Short string
72 
73 	// The group id under which this subcommand is grouped in the 'help' output of its parent.
74 	GroupID string
75 
76 	// Long is the long message shown in the 'help <this-command>' output.
77 	Long string
78 
79 	// Example is examples of how to use the command.
80 	Example string
81 
82 	// ValidArgs is list of all valid non-flag arguments that are accepted in shell completions
83 	ValidArgs []string
84 	// ValidArgsFunction is an optional function that provides valid non-flag arguments for shell completion.
85 	// It is a dynamic version of using ValidArgs.
86 	// Only one of ValidArgs and ValidArgsFunction can be used for a command.
87 	ValidArgsFunction func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)
88 
89 	// Expected arguments
90 	Args PositionalArgs
91 
92 	// ArgAliases is List of aliases for ValidArgs.
93 	// These are not suggested to the user in the shell completion,
94 	// but accepted if entered manually.
95 	ArgAliases []string
96 
97 	// BashCompletionFunction is custom bash functions used by the legacy bash autocompletion generator.
98 	// For portability with other shells, it is recommended to instead use ValidArgsFunction
99 	BashCompletionFunction string
100 
101 	// Deprecated defines, if this command is deprecated and should print this string when used.
102 	Deprecated string
103 
104 	// Annotations are key/value pairs that can be used by applications to identify or
105 	// group commands or set special options.
106 	Annotations map[string]string
107 
108 	// Version defines the version for this command. If this value is non-empty and the command does not
109 	// define a "version" flag, a "version" boolean flag will be added to the command and, if specified,
110 	// will print content of the "Version" variable. A shorthand "v" flag will also be added if the
111 	// command does not define one.
112 	Version string
113 
114 	// The *Run functions are executed in the following order:
115 	//   * PersistentPreRun()
116 	//   * PreRun()
117 	//   * Run()
118 	//   * PostRun()
119 	//   * PersistentPostRun()
120 	// All functions get the same args, the arguments after the command name.
121 	// The *PreRun and *PostRun functions will only be executed if the Run function of the current
122 	// command has been declared.
123 	//
124 	// PersistentPreRun: children of this command will inherit and execute.
125 	PersistentPreRun func(cmd *Command, args []string)
126 	// PersistentPreRunE: PersistentPreRun but returns an error.
127 	PersistentPreRunE func(cmd *Command, args []string) error
128 	// PreRun: children of this command will not inherit.
129 	PreRun func(cmd *Command, args []string)
130 	// PreRunE: PreRun but returns an error.
131 	PreRunE func(cmd *Command, args []string) error
132 	// Run: Typically the actual work function. Most commands will only implement this.
133 	Run func(cmd *Command, args []string)
134 	// RunE: Run but returns an error.
135 	RunE func(cmd *Command, args []string) error
136 	// PostRun: run after the Run command.
137 	PostRun func(cmd *Command, args []string)
138 	// PostRunE: PostRun but returns an error.
139 	PostRunE func(cmd *Command, args []string) error
140 	// PersistentPostRun: children of this command will inherit and execute after PostRun.
141 	PersistentPostRun func(cmd *Command, args []string)
142 	// PersistentPostRunE: PersistentPostRun but returns an error.
143 	PersistentPostRunE func(cmd *Command, args []string) error
144 
145 	// groups for subcommands
146 	commandgroups []*Group
147 
148 	// args is actual args parsed from flags.
149 	args []string
150 	// flagErrorBuf contains all error messages from pflag.
151 	flagErrorBuf *bytes.Buffer
152 	// flags is full set of flags.
153 	flags *flag.FlagSet
154 	// pflags contains persistent flags.
155 	pflags *flag.FlagSet
156 	// lflags contains local flags.
157 	// This field does not represent internal state, it's used as a cache to optimise LocalFlags function call
158 	lflags *flag.FlagSet
159 	// iflags contains inherited flags.
160 	// This field does not represent internal state, it's used as a cache to optimise InheritedFlags function call
161 	iflags *flag.FlagSet
162 	// parentsPflags is all persistent flags of cmd's parents.
163 	parentsPflags *flag.FlagSet
164 	// globNormFunc is the global normalization function
165 	// that we can use on every pflag set and children commands
166 	globNormFunc func(f *flag.FlagSet, name string) flag.NormalizedName
167 
168 	// usageFunc is usage func defined by user.
169 	usageFunc func(*Command) error
170 	// usageTemplate is usage template defined by user.
171 	usageTemplate string
172 	// flagErrorFunc is func defined by user and it's called when the parsing of
173 	// flags returns an error.
174 	flagErrorFunc func(*Command, error) error
175 	// helpTemplate is help template defined by user.
176 	helpTemplate string
177 	// helpFunc is help func defined by user.
178 	helpFunc func(*Command, []string)
179 	// helpCommand is command with usage 'help'. If it's not defined by user,
180 	// cobra uses default help command.
181 	helpCommand *Command
182 	// helpCommandGroupID is the group id for the helpCommand
183 	helpCommandGroupID string
184 
185 	// completionCommandGroupID is the group id for the completion command
186 	completionCommandGroupID string
187 
188 	// versionTemplate is the version template defined by user.
189 	versionTemplate string
190 
191 	// errPrefix is the error message prefix defined by user.
192 	errPrefix string
193 
194 	// inReader is a reader defined by the user that replaces stdin
195 	inReader io.Reader
196 	// outWriter is a writer defined by the user that replaces stdout
197 	outWriter io.Writer
198 	// errWriter is a writer defined by the user that replaces stderr
199 	errWriter io.Writer
200 
201 	// FParseErrWhitelist flag parse errors to be ignored
202 	FParseErrWhitelist FParseErrWhitelist
203 
204 	// CompletionOptions is a set of options to control the handling of shell completion
205 	CompletionOptions CompletionOptions
206 
207 	// commandsAreSorted defines, if command slice are sorted or not.
208 	commandsAreSorted bool
209 	// commandCalledAs is the name or alias value used to call this command.
210 	commandCalledAs struct {
211 		name   string
212 		called bool
213 	}
214 
215 	ctx context.Context
216 
217 	// commands is the list of commands supported by this program.
218 	commands []*Command
219 	// parent is a parent command for this command.
220 	parent *Command
221 	// Max lengths of commands' string lengths for use in padding.
222 	commandsMaxUseLen         int
223 	commandsMaxCommandPathLen int
224 	commandsMaxNameLen        int
225 
226 	// TraverseChildren parses flags on all parents before executing child command.
227 	TraverseChildren bool
228 
229 	// Hidden defines, if this command is hidden and should NOT show up in the list of available commands.
230 	Hidden bool
231 
232 	// SilenceErrors is an option to quiet errors down stream.
233 	SilenceErrors bool
234 
235 	// SilenceUsage is an option to silence usage when an error occurs.
236 	SilenceUsage bool
237 
238 	// DisableFlagParsing disables the flag parsing.
239 	// If this is true all flags will be passed to the command as arguments.
240 	DisableFlagParsing bool
241 
242 	// DisableAutoGenTag defines, if gen tag ("Auto generated by spf13/cobra...")
243 	// will be printed by generating docs for this command.
244 	DisableAutoGenTag bool
245 
246 	// DisableFlagsInUseLine will disable the addition of [flags] to the usage
247 	// line of a command when printing help or generating docs
248 	DisableFlagsInUseLine bool
249 
250 	// DisableSuggestions disables the suggestions based on Levenshtein distance
251 	// that go along with 'unknown command' messages.
252 	DisableSuggestions bool
253 
254 	// SuggestionsMinimumDistance defines minimum levenshtein distance to display suggestions.
255 	// Must be > 0.
256 	SuggestionsMinimumDistance int
257 }
258 
259 // Context returns underlying command context. If command was executed
260 // with ExecuteContext or the context was set with SetContext, the
261 // previously set context will be returned. Otherwise, nil is returned.
262 //
263 // Notice that a call to Execute and ExecuteC will replace a nil context of
264 // a command with a context.Background, so a background context will be
265 // returned by Context after one of these functions has been called.
266 func (c *Command) Context() context.Context {
267 	return c.ctx
268 }
269 
270 // SetContext sets context for the command. This context will be overwritten by
271 // Command.ExecuteContext or Command.ExecuteContextC.
272 func (c *Command) SetContext(ctx context.Context) {
273 	c.ctx = ctx
274 }
275 
276 // SetArgs sets arguments for the command. It is set to os.Args[1:] by default, if desired, can be overridden
277 // particularly useful when testing.
278 func (c *Command) SetArgs(a []string) {
279 	c.args = a
280 }
281 
282 // SetOutput sets the destination for usage and error messages.
283 // If output is nil, os.Stderr is used.
284 // Deprecated: Use SetOut and/or SetErr instead
285 func (c *Command) SetOutput(output io.Writer) {
286 	c.outWriter = output
287 	c.errWriter = output
288 }
289 
290 // SetOut sets the destination for usage messages.
291 // If newOut is nil, os.Stdout is used.
292 func (c *Command) SetOut(newOut io.Writer) {
293 	c.outWriter = newOut
294 }
295 
296 // SetErr sets the destination for error messages.
297 // If newErr is nil, os.Stderr is used.
298 func (c *Command) SetErr(newErr io.Writer) {
299 	c.errWriter = newErr
300 }
301 
302 // SetIn sets the source for input data
303 // If newIn is nil, os.Stdin is used.
304 func (c *Command) SetIn(newIn io.Reader) {
305 	c.inReader = newIn
306 }
307 
308 // SetUsageFunc sets usage function. Usage can be defined by application.
309 func (c *Command) SetUsageFunc(f func(*Command) error) {
310 	c.usageFunc = f
311 }
312 
313 // SetUsageTemplate sets usage template. Can be defined by Application.
314 func (c *Command) SetUsageTemplate(s string) {
315 	c.usageTemplate = s
316 }
317 
318 // SetFlagErrorFunc sets a function to generate an error when flag parsing
319 // fails.
320 func (c *Command) SetFlagErrorFunc(f func(*Command, error) error) {
321 	c.flagErrorFunc = f
322 }
323 
324 // SetHelpFunc sets help function. Can be defined by Application.
325 func (c *Command) SetHelpFunc(f func(*Command, []string)) {
326 	c.helpFunc = f
327 }
328 
329 // SetHelpCommand sets help command.
330 func (c *Command) SetHelpCommand(cmd *Command) {
331 	c.helpCommand = cmd
332 }
333 
334 // SetHelpCommandGroupID sets the group id of the help command.
335 func (c *Command) SetHelpCommandGroupID(groupID string) {
336 	if c.helpCommand != nil {
337 		c.helpCommand.GroupID = groupID
338 	}
339 	// helpCommandGroupID is used if no helpCommand is defined by the user
340 	c.helpCommandGroupID = groupID
341 }
342 
343 // SetCompletionCommandGroupID sets the group id of the completion command.
344 func (c *Command) SetCompletionCommandGroupID(groupID string) {
345 	// completionCommandGroupID is used if no completion command is defined by the user
346 	c.Root().completionCommandGroupID = groupID
347 }
348 
349 // SetHelpTemplate sets help template to be used. Application can use it to set custom template.
350 func (c *Command) SetHelpTemplate(s string) {
351 	c.helpTemplate = s
352 }
353 
354 // SetVersionTemplate sets version template to be used. Application can use it to set custom template.
355 func (c *Command) SetVersionTemplate(s string) {
356 	c.versionTemplate = s
357 }
358 
359 // SetErrPrefix sets error message prefix to be used. Application can use it to set custom prefix.
360 func (c *Command) SetErrPrefix(s string) {
361 	c.errPrefix = s
362 }
363 
364 // SetGlobalNormalizationFunc sets a normalization function to all flag sets and also to child commands.
365 // The user should not have a cyclic dependency on commands.
366 func (c *Command) SetGlobalNormalizationFunc(n func(f *flag.FlagSet, name string) flag.NormalizedName) {
367 	c.Flags().SetNormalizeFunc(n)
368 	c.PersistentFlags().SetNormalizeFunc(n)
369 	c.globNormFunc = n
370 
371 	for _, command := range c.commands {
372 		command.SetGlobalNormalizationFunc(n)
373 	}
374 }
375 
376 // OutOrStdout returns output to stdout.
377 func (c *Command) OutOrStdout() io.Writer {
378 	return c.getOut(os.Stdout)
379 }
380 
381 // OutOrStderr returns output to stderr
382 func (c *Command) OutOrStderr() io.Writer {
383 	return c.getOut(os.Stderr)
384 }
385 
386 // ErrOrStderr returns output to stderr
387 func (c *Command) ErrOrStderr() io.Writer {
388 	return c.getErr(os.Stderr)
389 }
390 
391 // InOrStdin returns input to stdin
392 func (c *Command) InOrStdin() io.Reader {
393 	return c.getIn(os.Stdin)
394 }
395 
396 func (c *Command) getOut(def io.Writer) io.Writer {
397 	if c.outWriter != nil {
398 		return c.outWriter
399 	}
400 	if c.HasParent() {
401 		return c.parent.getOut(def)
402 	}
403 	return def
404 }
405 
406 func (c *Command) getErr(def io.Writer) io.Writer {
407 	if c.errWriter != nil {
408 		return c.errWriter
409 	}
410 	if c.HasParent() {
411 		return c.parent.getErr(def)
412 	}
413 	return def
414 }
415 
416 func (c *Command) getIn(def io.Reader) io.Reader {
417 	if c.inReader != nil {
418 		return c.inReader
419 	}
420 	if c.HasParent() {
421 		return c.parent.getIn(def)
422 	}
423 	return def
424 }
425 
426 // UsageFunc returns either the function set by SetUsageFunc for this command
427 // or a parent, or it returns a default usage function.
428 func (c *Command) UsageFunc() (f func(*Command) error) {
429 	if c.usageFunc != nil {
430 		return c.usageFunc
431 	}
432 	if c.HasParent() {
433 		return c.Parent().UsageFunc()
434 	}
435 	return func(c *Command) error {
436 		c.mergePersistentFlags()
437 		err := tmpl(c.OutOrStderr(), c.UsageTemplate(), c)
438 		if err != nil {
439 			c.PrintErrln(err)
440 		}
441 		return err
442 	}
443 }
444 
445 // Usage puts out the usage for the command.
446 // Used when a user provides invalid input.
447 // Can be defined by user by overriding UsageFunc.
448 func (c *Command) Usage() error {
449 	return c.UsageFunc()(c)
450 }
451 
452 // HelpFunc returns either the function set by SetHelpFunc for this command
453 // or a parent, or it returns a function with default help behavior.
454 func (c *Command) HelpFunc() func(*Command, []string) {
455 	if c.helpFunc != nil {
456 		return c.helpFunc
457 	}
458 	if c.HasParent() {
459 		return c.Parent().HelpFunc()
460 	}
461 	return func(c *Command, a []string) {
462 		c.mergePersistentFlags()
463 		// The help should be sent to stdout
464 		// See https://github.com/spf13/cobra/issues/1002
465 		err := tmpl(c.OutOrStdout(), c.HelpTemplate(), c)
466 		if err != nil {
467 			c.PrintErrln(err)
468 		}
469 	}
470 }
471 
472 // Help puts out the help for the command.
473 // Used when a user calls help [command].
474 // Can be defined by user by overriding HelpFunc.
475 func (c *Command) Help() error {
476 	c.HelpFunc()(c, []string{})
477 	return nil
478 }
479 
480 // UsageString returns usage string.
481 func (c *Command) UsageString() string {
482 	// Storing normal writers
483 	tmpOutput := c.outWriter
484 	tmpErr := c.errWriter
485 
486 	bb := new(bytes.Buffer)
487 	c.outWriter = bb
488 	c.errWriter = bb
489 
490 	CheckErr(c.Usage())
491 
492 	// Setting things back to normal
493 	c.outWriter = tmpOutput
494 	c.errWriter = tmpErr
495 
496 	return bb.String()
497 }
498 
499 // FlagErrorFunc returns either the function set by SetFlagErrorFunc for this
500 // command or a parent, or it returns a function which returns the original
501 // error.
502 func (c *Command) FlagErrorFunc() (f func(*Command, error) error) {
503 	if c.flagErrorFunc != nil {
504 		return c.flagErrorFunc
505 	}
506 
507 	if c.HasParent() {
508 		return c.parent.FlagErrorFunc()
509 	}
510 	return func(c *Command, err error) error {
511 		return err
512 	}
513 }
514 
515 var minUsagePadding = 25
516 
517 // UsagePadding return padding for the usage.
518 func (c *Command) UsagePadding() int {
519 	if c.parent == nil || minUsagePadding > c.parent.commandsMaxUseLen {
520 		return minUsagePadding
521 	}
522 	return c.parent.commandsMaxUseLen
523 }
524 
525 var minCommandPathPadding = 11
526 
527 // CommandPathPadding return padding for the command path.
528 func (c *Command) CommandPathPadding() int {
529 	if c.parent == nil || minCommandPathPadding > c.parent.commandsMaxCommandPathLen {
530 		return minCommandPathPadding
531 	}
532 	return c.parent.commandsMaxCommandPathLen
533 }
534 
535 var minNamePadding = 11
536 
537 // NamePadding returns padding for the name.
538 func (c *Command) NamePadding() int {
539 	if c.parent == nil || minNamePadding > c.parent.commandsMaxNameLen {
540 		return minNamePadding
541 	}
542 	return c.parent.commandsMaxNameLen
543 }
544 
545 // UsageTemplate returns usage template for the command.
546 func (c *Command) UsageTemplate() string {
547 	if c.usageTemplate != "" {
548 		return c.usageTemplate
549 	}
550 
551 	if c.HasParent() {
552 		return c.parent.UsageTemplate()
553 	}
554 	return `Usage:{{if .Runnable}}
555   {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
556   {{.CommandPath}} [command]{{end}}{{if gt (len .Aliases) 0}}
557 
558 Aliases:
559   {{.NameAndAliases}}{{end}}{{if .HasExample}}
560 
561 Examples:
562 {{.Example}}{{end}}{{if .HasAvailableSubCommands}}{{$cmds := .Commands}}{{if eq (len .Groups) 0}}
563 
564 Available Commands:{{range $cmds}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
565   {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{else}}{{range $group := .Groups}}
566 
567 {{.Title}}{{range $cmds}}{{if (and (eq .GroupID $group.ID) (or .IsAvailableCommand (eq .Name "help")))}}
568   {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{if not .AllChildCommandsHaveGroup}}
569 
570 Additional Commands:{{range $cmds}}{{if (and (eq .GroupID "") (or .IsAvailableCommand (eq .Name "help")))}}
571   {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}
572 
573 Flags:
574 {{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasAvailableInheritedFlags}}
575 
576 Global Flags:
577 {{.InheritedFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasHelpSubCommands}}
578 
579 Additional help topics:{{range .Commands}}{{if .IsAdditionalHelpTopicCommand}}
580   {{rpad .CommandPath .CommandPathPadding}} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableSubCommands}}
581 
582 Use "{{.CommandPath}} [command] --help" for more information about a command.{{end}}
583 `
584 }
585 
586 // HelpTemplate return help template for the command.
587 func (c *Command) HelpTemplate() string {
588 	if c.helpTemplate != "" {
589 		return c.helpTemplate
590 	}
591 
592 	if c.HasParent() {
593 		return c.parent.HelpTemplate()
594 	}
595 	return `{{with (or .Long .Short)}}{{. | trimTrailingWhitespaces}}
596 
597 {{end}}{{if or .Runnable .HasSubCommands}}{{.UsageString}}{{end}}`
598 }
599 
600 // VersionTemplate return version template for the command.
601 func (c *Command) VersionTemplate() string {
602 	if c.versionTemplate != "" {
603 		return c.versionTemplate
604 	}
605 
606 	if c.HasParent() {
607 		return c.parent.VersionTemplate()
608 	}
609 	return `{{with .Name}}{{printf "%s " .}}{{end}}{{printf "version %s" .Version}}
610 `
611 }
612 
613 // ErrPrefix return error message prefix for the command
614 func (c *Command) ErrPrefix() string {
615 	if c.errPrefix != "" {
616 		return c.errPrefix
617 	}
618 
619 	if c.HasParent() {
620 		return c.parent.ErrPrefix()
621 	}
622 	return "Error:"
623 }
624 
625 func hasNoOptDefVal(name string, fs *flag.FlagSet) bool {
626 	flag := fs.Lookup(name)
627 	if flag == nil {
628 		return false
629 	}
630 	return flag.NoOptDefVal != ""
631 }
632 
633 func shortHasNoOptDefVal(name string, fs *flag.FlagSet) bool {
634 	if len(name) == 0 {
635 		return false
636 	}
637 
638 	flag := fs.ShorthandLookup(name[:1])
639 	if flag == nil {
640 		return false
641 	}
642 	return flag.NoOptDefVal != ""
643 }
644 
645 func stripFlags(args []string, c *Command) []string {
646 	if len(args) == 0 {
647 		return args
648 	}
649 	c.mergePersistentFlags()
650 
651 	commands := []string{}
652 	flags := c.Flags()
653 
654 Loop:
655 	for len(args) > 0 {
656 		s := args[0]
657 		args = args[1:]
658 		switch {
659 		case s == "--":
660 			// "--" terminates the flags
661 			break Loop
662 		case strings.HasPrefix(s, "--") && !strings.Contains(s, "=") && !hasNoOptDefVal(s[2:], flags):
663 			// If '--flag arg' then
664 			// delete arg from args.
665 			fallthrough // (do the same as below)
666 		case strings.HasPrefix(s, "-") && !strings.Contains(s, "=") && len(s) == 2 && !shortHasNoOptDefVal(s[1:], flags):
667 			// If '-f arg' then
668 			// delete 'arg' from args or break the loop if len(args) <= 1.
669 			if len(args) <= 1 {
670 				break Loop
671 			} else {
672 				args = args[1:]
673 				continue
674 			}
675 		case s != "" && !strings.HasPrefix(s, "-"):
676 			commands = append(commands, s)
677 		}
678 	}
679 
680 	return commands
681 }
682 
683 // argsMinusFirstX removes only the first x from args.  Otherwise, commands that look like
684 // openshift admin policy add-role-to-user admin my-user, lose the admin argument (arg[4]).
685 // Special care needs to be taken not to remove a flag value.
686 func (c *Command) argsMinusFirstX(args []string, x string) []string {
687 	if len(args) == 0 {
688 		return args
689 	}
690 	c.mergePersistentFlags()
691 	flags := c.Flags()
692 
693 Loop:
694 	for pos := 0; pos < len(args); pos++ {
695 		s := args[pos]
696 		switch {
697 		case s == "--":
698 			// -- means we have reached the end of the parseable args. Break out of the loop now.
699 			break Loop
700 		case strings.HasPrefix(s, "--") && !strings.Contains(s, "=") && !hasNoOptDefVal(s[2:], flags):
701 			fallthrough
702 		case strings.HasPrefix(s, "-") && !strings.Contains(s, "=") && len(s) == 2 && !shortHasNoOptDefVal(s[1:], flags):
703 			// This is a flag without a default value, and an equal sign is not used. Increment pos in order to skip
704 			// over the next arg, because that is the value of this flag.
705 			pos++
706 			continue
707 		case !strings.HasPrefix(s, "-"):
708 			// This is not a flag or a flag value. Check to see if it matches what we're looking for, and if so,
709 			// return the args, excluding the one at this position.
710 			if s == x {
711 				ret := make([]string, 0, len(args)-1)
712 				ret = append(ret, args[:pos]...)
713 				ret = append(ret, args[pos+1:]...)
714 				return ret
715 			}
716 		}
717 	}
718 	return args
719 }
720 
721 func isFlagArg(arg string) bool {
722 	return ((len(arg) >= 3 && arg[0:2] == "--") ||
723 		(len(arg) >= 2 && arg[0] == '-' && arg[1] != '-'))
724 }
725 
726 // Find the target command given the args and command tree
727 // Meant to be run on the highest node. Only searches down.
728 func (c *Command) Find(args []string) (*Command, []string, error) {
729 	var innerfind func(*Command, []string) (*Command, []string)
730 
731 	innerfind = func(c *Command, innerArgs []string) (*Command, []string) {
732 		argsWOflags := stripFlags(innerArgs, c)
733 		if len(argsWOflags) == 0 {
734 			return c, innerArgs
735 		}
736 		nextSubCmd := argsWOflags[0]
737 
738 		cmd := c.findNext(nextSubCmd)
739 		if cmd != nil {
740 			return innerfind(cmd, c.argsMinusFirstX(innerArgs, nextSubCmd))
741 		}
742 		return c, innerArgs
743 	}
744 
745 	commandFound, a := innerfind(c, args)
746 	if commandFound.Args == nil {
747 		return commandFound, a, legacyArgs(commandFound, stripFlags(a, commandFound))
748 	}
749 	return commandFound, a, nil
750 }
751 
752 func (c *Command) findSuggestions(arg string) string {
753 	if c.DisableSuggestions {
754 		return ""
755 	}
756 	if c.SuggestionsMinimumDistance <= 0 {
757 		c.SuggestionsMinimumDistance = 2
758 	}
759 	var sb strings.Builder
760 	if suggestions := c.SuggestionsFor(arg); len(suggestions) > 0 {
761 		sb.WriteString("\n\nDid you mean this?\n")
762 		for _, s := range suggestions {
763 			_, _ = fmt.Fprintf(&sb, "\t%v\n", s)
764 		}
765 	}
766 	return sb.String()
767 }
768 
769 func (c *Command) findNext(next string) *Command {
770 	matches := make([]*Command, 0)
771 	for _, cmd := range c.commands {
772 		if commandNameMatches(cmd.Name(), next) || cmd.HasAlias(next) {
773 			cmd.commandCalledAs.name = next
774 			return cmd
775 		}
776 		if EnablePrefixMatching && cmd.hasNameOrAliasPrefix(next) {
777 			matches = append(matches, cmd)
778 		}
779 	}
780 
781 	if len(matches) == 1 {
782 		// Temporarily disable gosec G602, which produces a false positive.
783 		// See https://github.com/securego/gosec/issues/1005.
784 		return matches[0] // #nosec G602
785 	}
786 
787 	return nil
788 }
789 
790 // Traverse the command tree to find the command, and parse args for
791 // each parent.
792 func (c *Command) Traverse(args []string) (*Command, []string, error) {
793 	flags := []string{}
794 	inFlag := false
795 
796 	for i, arg := range args {
797 		switch {
798 		// A long flag with a space separated value
799 		case strings.HasPrefix(arg, "--") && !strings.Contains(arg, "="):
800 			// TODO: this isn't quite right, we should really check ahead for 'true' or 'false'
801 			inFlag = !hasNoOptDefVal(arg[2:], c.Flags())
802 			flags = append(flags, arg)
803 			continue
804 		// A short flag with a space separated value
805 		case strings.HasPrefix(arg, "-") && !strings.Contains(arg, "=") && len(arg) == 2 && !shortHasNoOptDefVal(arg[1:], c.Flags()):
806 			inFlag = true
807 			flags = append(flags, arg)
808 			continue
809 		// The value for a flag
810 		case inFlag:
811 			inFlag = false
812 			flags = append(flags, arg)
813 			continue
814 		// A flag without a value, or with an `=` separated value
815 		case isFlagArg(arg):
816 			flags = append(flags, arg)
817 			continue
818 		}
819 
820 		cmd := c.findNext(arg)
821 		if cmd == nil {
822 			return c, args, nil
823 		}
824 
825 		if err := c.ParseFlags(flags); err != nil {
826 			return nil, args, err
827 		}
828 		return cmd.Traverse(args[i+1:])
829 	}
830 	return c, args, nil
831 }
832 
833 // SuggestionsFor provides suggestions for the typedName.
834 func (c *Command) SuggestionsFor(typedName string) []string {
835 	suggestions := []string{}
836 	for _, cmd := range c.commands {
837 		if cmd.IsAvailableCommand() {
838 			levenshteinDistance := ld(typedName, cmd.Name(), true)
839 			suggestByLevenshtein := levenshteinDistance <= c.SuggestionsMinimumDistance
840 			suggestByPrefix := strings.HasPrefix(strings.ToLower(cmd.Name()), strings.ToLower(typedName))
841 			if suggestByLevenshtein || suggestByPrefix {
842 				suggestions = append(suggestions, cmd.Name())
843 			}
844 			for _, explicitSuggestion := range cmd.SuggestFor {
845 				if strings.EqualFold(typedName, explicitSuggestion) {
846 					suggestions = append(suggestions, cmd.Name())
847 				}
848 			}
849 		}
850 	}
851 	return suggestions
852 }
853 
854 // VisitParents visits all parents of the command and invokes fn on each parent.
855 func (c *Command) VisitParents(fn func(*Command)) {
856 	if c.HasParent() {
857 		fn(c.Parent())
858 		c.Parent().VisitParents(fn)
859 	}
860 }
861 
862 // Root finds root command.
863 func (c *Command) Root() *Command {
864 	if c.HasParent() {
865 		return c.Parent().Root()
866 	}
867 	return c
868 }
869 
870 // ArgsLenAtDash will return the length of c.Flags().Args at the moment
871 // when a -- was found during args parsing.
872 func (c *Command) ArgsLenAtDash() int {
873 	return c.Flags().ArgsLenAtDash()
874 }
875 
876 func (c *Command) execute(a []string) (err error) {
877 	if c == nil {
878 		return fmt.Errorf("called Execute() on a nil Command")
879 	}
880 
881 	if len(c.Deprecated) > 0 {
882 		c.Printf("Command %q is deprecated, %s\n", c.Name(), c.Deprecated)
883 	}
884 
885 	// initialize help and version flag at the last point possible to allow for user
886 	// overriding
887 	c.InitDefaultHelpFlag()
888 	c.InitDefaultVersionFlag()
889 
890 	err = c.ParseFlags(a)
891 	if err != nil {
892 		return c.FlagErrorFunc()(c, err)
893 	}
894 
895 	// If help is called, regardless of other flags, return we want help.
896 	// Also say we need help if the command isn't runnable.
897 	helpVal, err := c.Flags().GetBool("help")
898 	if err != nil {
899 		// should be impossible to get here as we always declare a help
900 		// flag in InitDefaultHelpFlag()
901 		c.Println("\"help\" flag declared as non-bool. Please correct your code")
902 		return err
903 	}
904 
905 	if helpVal {
906 		return flag.ErrHelp
907 	}
908 
909 	// for back-compat, only add version flag behavior if version is defined
910 	if c.Version != "" {
911 		versionVal, err := c.Flags().GetBool("version")
912 		if err != nil {
913 			c.Println("\"version\" flag declared as non-bool. Please correct your code")
914 			return err
915 		}
916 		if versionVal {
917 			err := tmpl(c.OutOrStdout(), c.VersionTemplate(), c)
918 			if err != nil {
919 				c.Println(err)
920 			}
921 			return err
922 		}
923 	}
924 
925 	if !c.Runnable() {
926 		return flag.ErrHelp
927 	}
928 
929 	c.preRun()
930 
931 	defer c.postRun()
932 
933 	argWoFlags := c.Flags().Args()
934 	if c.DisableFlagParsing {
935 		argWoFlags = a
936 	}
937 
938 	if err := c.ValidateArgs(argWoFlags); err != nil {
939 		return err
940 	}
941 
942 	parents := make([]*Command, 0, 5)
943 	for p := c; p != nil; p = p.Parent() {
944 		if EnableTraverseRunHooks {
945 			// When EnableTraverseRunHooks is set:
946 			// - Execute all persistent pre-runs from the root parent till this command.
947 			// - Execute all persistent post-runs from this command till the root parent.
948 			parents = append([]*Command{p}, parents...)
949 		} else {
950 			// Otherwise, execute only the first found persistent hook.
951 			parents = append(parents, p)
952 		}
953 	}
954 	for _, p := range parents {
955 		if p.PersistentPreRunE != nil {
956 			if err := p.PersistentPreRunE(c, argWoFlags); err != nil {
957 				return err
958 			}
959 			if !EnableTraverseRunHooks {
960 				break
961 			}
962 		} else if p.PersistentPreRun != nil {
963 			p.PersistentPreRun(c, argWoFlags)
964 			if !EnableTraverseRunHooks {
965 				break
966 			}
967 		}
968 	}
969 	if c.PreRunE != nil {
970 		if err := c.PreRunE(c, argWoFlags); err != nil {
971 			return err
972 		}
973 	} else if c.PreRun != nil {
974 		c.PreRun(c, argWoFlags)
975 	}
976 
977 	if err := c.ValidateRequiredFlags(); err != nil {
978 		return err
979 	}
980 	if err := c.ValidateFlagGroups(); err != nil {
981 		return err
982 	}
983 
984 	if c.RunE != nil {
985 		if err := c.RunE(c, argWoFlags); err != nil {
986 			return err
987 		}
988 	} else {
989 		c.Run(c, argWoFlags)
990 	}
991 	if c.PostRunE != nil {
992 		if err := c.PostRunE(c, argWoFlags); err != nil {
993 			return err
994 		}
995 	} else if c.PostRun != nil {
996 		c.PostRun(c, argWoFlags)
997 	}
998 	for p := c; p != nil; p = p.Parent() {
999 		if p.PersistentPostRunE != nil {
1000 			if err := p.PersistentPostRunE(c, argWoFlags); err != nil {
1001 				return err
1002 			}
1003 			if !EnableTraverseRunHooks {
1004 				break
1005 			}
1006 		} else if p.PersistentPostRun != nil {
1007 			p.PersistentPostRun(c, argWoFlags)
1008 			if !EnableTraverseRunHooks {
1009 				break
1010 			}
1011 		}
1012 	}
1013 
1014 	return nil
1015 }
1016 
1017 func (c *Command) preRun() {
1018 	for _, x := range initializers {
1019 		x()
1020 	}
1021 }
1022 
1023 func (c *Command) postRun() {
1024 	for _, x := range finalizers {
1025 		x()
1026 	}
1027 }
1028 
1029 // ExecuteContext is the same as Execute(), but sets the ctx on the command.
1030 // Retrieve ctx by calling cmd.Context() inside your *Run lifecycle or ValidArgs
1031 // functions.
1032 func (c *Command) ExecuteContext(ctx context.Context) error {
1033 	c.ctx = ctx
1034 	return c.Execute()
1035 }
1036 
1037 // Execute uses the args (os.Args[1:] by default)
1038 // and run through the command tree finding appropriate matches
1039 // for commands and then corresponding flags.
1040 func (c *Command) Execute() error {
1041 	_, err := c.ExecuteC()
1042 	return err
1043 }
1044 
1045 // ExecuteContextC is the same as ExecuteC(), but sets the ctx on the command.
1046 // Retrieve ctx by calling cmd.Context() inside your *Run lifecycle or ValidArgs
1047 // functions.
1048 func (c *Command) ExecuteContextC(ctx context.Context) (*Command, error) {
1049 	c.ctx = ctx
1050 	return c.ExecuteC()
1051 }
1052 
1053 // ExecuteC executes the command.
1054 func (c *Command) ExecuteC() (cmd *Command, err error) {
1055 	if c.ctx == nil {
1056 		c.ctx = context.Background()
1057 	}
1058 
1059 	// Regardless of what command execute is called on, run on Root only
1060 	if c.HasParent() {
1061 		return c.Root().ExecuteC()
1062 	}
1063 
1064 	// windows hook
1065 	if preExecHookFn != nil {
1066 		preExecHookFn(c)
1067 	}
1068 
1069 	// initialize help at the last point to allow for user overriding
1070 	c.InitDefaultHelpCmd()
1071 	// initialize completion at the last point to allow for user overriding
1072 	c.InitDefaultCompletionCmd()
1073 
1074 	// Now that all commands have been created, let's make sure all groups
1075 	// are properly created also
1076 	c.checkCommandGroups()
1077 
1078 	args := c.args
1079 
1080 	// Workaround FAIL with "go test -v" or "cobra.test -test.v", see #155
1081 	if c.args == nil && filepath.Base(os.Args[0]) != "cobra.test" {
1082 		args = os.Args[1:]
1083 	}
1084 
1085 	// initialize the hidden command to be used for shell completion
1086 	c.initCompleteCmd(args)
1087 
1088 	var flags []string
1089 	if c.TraverseChildren {
1090 		cmd, flags, err = c.Traverse(args)
1091 	} else {
1092 		cmd, flags, err = c.Find(args)
1093 	}
1094 	if err != nil {
1095 		// If found parse to a subcommand and then failed, talk about the subcommand
1096 		if cmd != nil {
1097 			c = cmd
1098 		}
1099 		if !c.SilenceErrors {
1100 			c.PrintErrln(c.ErrPrefix(), err.Error())
1101 			c.PrintErrf("Run '%v --help' for usage.\n", c.CommandPath())
1102 		}
1103 		return c, err
1104 	}
1105 
1106 	cmd.commandCalledAs.called = true
1107 	if cmd.commandCalledAs.name == "" {
1108 		cmd.commandCalledAs.name = cmd.Name()
1109 	}
1110 
1111 	// We have to pass global context to children command
1112 	// if context is present on the parent command.
1113 	if cmd.ctx == nil {
1114 		cmd.ctx = c.ctx
1115 	}
1116 
1117 	err = cmd.execute(flags)
1118 	if err != nil {
1119 		// Always show help if requested, even if SilenceErrors is in
1120 		// effect
1121 		if errors.Is(err, flag.ErrHelp) {
1122 			cmd.HelpFunc()(cmd, args)
1123 			return cmd, nil
1124 		}
1125 
1126 		// If root command has SilenceErrors flagged,
1127 		// all subcommands should respect it
1128 		if !cmd.SilenceErrors && !c.SilenceErrors {
1129 			c.PrintErrln(cmd.ErrPrefix(), err.Error())
1130 		}
1131 
1132 		// If root command has SilenceUsage flagged,
1133 		// all subcommands should respect it
1134 		if !cmd.SilenceUsage && !c.SilenceUsage {
1135 			c.Println(cmd.UsageString())
1136 		}
1137 	}
1138 	return cmd, err
1139 }
1140 
1141 func (c *Command) ValidateArgs(args []string) error {
1142 	if c.Args == nil {
1143 		return ArbitraryArgs(c, args)
1144 	}
1145 	return c.Args(c, args)
1146 }
1147 
1148 // ValidateRequiredFlags validates all required flags are present and returns an error otherwise
1149 func (c *Command) ValidateRequiredFlags() error {
1150 	if c.DisableFlagParsing {
1151 		return nil
1152 	}
1153 
1154 	flags := c.Flags()
1155 	missingFlagNames := []string{}
1156 	flags.VisitAll(func(pflag *flag.Flag) {
1157 		requiredAnnotation, found := pflag.Annotations[BashCompOneRequiredFlag]
1158 		if !found {
1159 			return
1160 		}
1161 		if (requiredAnnotation[0] == "true") && !pflag.Changed {
1162 			missingFlagNames = append(missingFlagNames, pflag.Name)
1163 		}
1164 	})
1165 
1166 	if len(missingFlagNames) > 0 {
1167 		return fmt.Errorf(`required flag(s) "%s" not set`, strings.Join(missingFlagNames, `", "`))
1168 	}
1169 	return nil
1170 }
1171 
1172 // checkCommandGroups checks if a command has been added to a group that does not exists.
1173 // If so, we panic because it indicates a coding error that should be corrected.
1174 func (c *Command) checkCommandGroups() {
1175 	for _, sub := range c.commands {
1176 		// if Group is not defined let the developer know right away
1177 		if sub.GroupID != "" && !c.ContainsGroup(sub.GroupID) {
1178 			panic(fmt.Sprintf("group id '%s' is not defined for subcommand '%s'", sub.GroupID, sub.CommandPath()))
1179 		}
1180 
1181 		sub.checkCommandGroups()
1182 	}
1183 }
1184 
1185 // InitDefaultHelpFlag adds default help flag to c.
1186 // It is called automatically by executing the c or by calling help and usage.
1187 // If c already has help flag, it will do nothing.
1188 func (c *Command) InitDefaultHelpFlag() {
1189 	c.mergePersistentFlags()
1190 	if c.Flags().Lookup("help") == nil {
1191 		usage := "help for "
1192 		name := c.displayName()
1193 		if name == "" {
1194 			usage += "this command"
1195 		} else {
1196 			usage += name
1197 		}
1198 		c.Flags().BoolP("help", "h", false, usage)
1199 		_ = c.Flags().SetAnnotation("help", FlagSetByCobraAnnotation, []string{"true"})
1200 	}
1201 }
1202 
1203 // InitDefaultVersionFlag adds default version flag to c.
1204 // It is called automatically by executing the c.
1205 // If c already has a version flag, it will do nothing.
1206 // If c.Version is empty, it will do nothing.
1207 func (c *Command) InitDefaultVersionFlag() {
1208 	if c.Version == "" {
1209 		return
1210 	}
1211 
1212 	c.mergePersistentFlags()
1213 	if c.Flags().Lookup("version") == nil {
1214 		usage := "version for "
1215 		if c.Name() == "" {
1216 			usage += "this command"
1217 		} else {
1218 			usage += c.Name()
1219 		}
1220 		if c.Flags().ShorthandLookup("v") == nil {
1221 			c.Flags().BoolP("version", "v", false, usage)
1222 		} else {
1223 			c.Flags().Bool("version", false, usage)
1224 		}
1225 		_ = c.Flags().SetAnnotation("version", FlagSetByCobraAnnotation, []string{"true"})
1226 	}
1227 }
1228 
1229 // InitDefaultHelpCmd adds default help command to c.
1230 // It is called automatically by executing the c or by calling help and usage.
1231 // If c already has help command or c has no subcommands, it will do nothing.
1232 func (c *Command) InitDefaultHelpCmd() {
1233 	if !c.HasSubCommands() {
1234 		return
1235 	}
1236 
1237 	if c.helpCommand == nil {
1238 		c.helpCommand = &Command{
1239 			Use:   "help [command]",
1240 			Short: "Help about any command",
1241 			Long: `Help provides help for any command in the application.
1242 Simply type ` + c.displayName() + ` help [path to command] for full details.`,
1243 			ValidArgsFunction: func(c *Command, args []string, toComplete string) ([]string, ShellCompDirective) {
1244 				var completions []string
1245 				cmd, _, e := c.Root().Find(args)
1246 				if e != nil {
1247 					return nil, ShellCompDirectiveNoFileComp
1248 				}
1249 				if cmd == nil {
1250 					// Root help command.
1251 					cmd = c.Root()
1252 				}
1253 				for _, subCmd := range cmd.Commands() {
1254 					if subCmd.IsAvailableCommand() || subCmd == cmd.helpCommand {
1255 						if strings.HasPrefix(subCmd.Name(), toComplete) {
1256 							completions = append(completions, fmt.Sprintf("%s\t%s", subCmd.Name(), subCmd.Short))
1257 						}
1258 					}
1259 				}
1260 				return completions, ShellCompDirectiveNoFileComp
1261 			},
1262 			Run: func(c *Command, args []string) {
1263 				cmd, _, e := c.Root().Find(args)
1264 				if cmd == nil || e != nil {
1265 					c.Printf("Unknown help topic %#q\n", args)
1266 					CheckErr(c.Root().Usage())
1267 				} else {
1268 					cmd.InitDefaultHelpFlag()    // make possible 'help' flag to be shown
1269 					cmd.InitDefaultVersionFlag() // make possible 'version' flag to be shown
1270 					CheckErr(cmd.Help())
1271 				}
1272 			},
1273 			GroupID: c.helpCommandGroupID,
1274 		}
1275 	}
1276 	c.RemoveCommand(c.helpCommand)
1277 	c.AddCommand(c.helpCommand)
1278 }
1279 
1280 // ResetCommands delete parent, subcommand and help command from c.
1281 func (c *Command) ResetCommands() {
1282 	c.parent = nil
1283 	c.commands = nil
1284 	c.helpCommand = nil
1285 	c.parentsPflags = nil
1286 }
1287 
1288 // Sorts commands by their names.
1289 type commandSorterByName []*Command
1290 
1291 func (c commandSorterByName) Len() int           { return len(c) }
1292 func (c commandSorterByName) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
1293 func (c commandSorterByName) Less(i, j int) bool { return c[i].Name() < c[j].Name() }
1294 
1295 // Commands returns a sorted slice of child commands.
1296 func (c *Command) Commands() []*Command {
1297 	// do not sort commands if it already sorted or sorting was disabled
1298 	if EnableCommandSorting && !c.commandsAreSorted {
1299 		sort.Sort(commandSorterByName(c.commands))
1300 		c.commandsAreSorted = true
1301 	}
1302 	return c.commands
1303 }
1304 
1305 // AddCommand adds one or more commands to this parent command.
1306 func (c *Command) AddCommand(cmds ...*Command) {
1307 	for i, x := range cmds {
1308 		if cmds[i] == c {
1309 			panic("Command can't be a child of itself")
1310 		}
1311 		cmds[i].parent = c
1312 		// update max lengths
1313 		usageLen := len(x.Use)
1314 		if usageLen > c.commandsMaxUseLen {
1315 			c.commandsMaxUseLen = usageLen
1316 		}
1317 		commandPathLen := len(x.CommandPath())
1318 		if commandPathLen > c.commandsMaxCommandPathLen {
1319 			c.commandsMaxCommandPathLen = commandPathLen
1320 		}
1321 		nameLen := len(x.Name())
1322 		if nameLen > c.commandsMaxNameLen {
1323 			c.commandsMaxNameLen = nameLen
1324 		}
1325 		// If global normalization function exists, update all children
1326 		if c.globNormFunc != nil {
1327 			x.SetGlobalNormalizationFunc(c.globNormFunc)
1328 		}
1329 		c.commands = append(c.commands, x)
1330 		c.commandsAreSorted = false
1331 	}
1332 }
1333 
1334 // Groups returns a slice of child command groups.
1335 func (c *Command) Groups() []*Group {
1336 	return c.commandgroups
1337 }
1338 
1339 // AllChildCommandsHaveGroup returns if all subcommands are assigned to a group
1340 func (c *Command) AllChildCommandsHaveGroup() bool {
1341 	for _, sub := range c.commands {
1342 		if (sub.IsAvailableCommand() || sub == c.helpCommand) && sub.GroupID == "" {
1343 			return false
1344 		}
1345 	}
1346 	return true
1347 }
1348 
1349 // ContainsGroup return if groupID exists in the list of command groups.
1350 func (c *Command) ContainsGroup(groupID string) bool {
1351 	for _, x := range c.commandgroups {
1352 		if x.ID == groupID {
1353 			return true
1354 		}
1355 	}
1356 	return false
1357 }
1358 
1359 // AddGroup adds one or more command groups to this parent command.
1360 func (c *Command) AddGroup(groups ...*Group) {
1361 	c.commandgroups = append(c.commandgroups, groups...)
1362 }
1363 
1364 // RemoveCommand removes one or more commands from a parent command.
1365 func (c *Command) RemoveCommand(cmds ...*Command) {
1366 	commands := []*Command{}
1367 main:
1368 	for _, command := range c.commands {
1369 		for _, cmd := range cmds {
1370 			if command == cmd {
1371 				command.parent = nil
1372 				continue main
1373 			}
1374 		}
1375 		commands = append(commands, command)
1376 	}
1377 	c.commands = commands
1378 	// recompute all lengths
1379 	c.commandsMaxUseLen = 0
1380 	c.commandsMaxCommandPathLen = 0
1381 	c.commandsMaxNameLen = 0
1382 	for _, command := range c.commands {
1383 		usageLen := len(command.Use)
1384 		if usageLen > c.commandsMaxUseLen {
1385 			c.commandsMaxUseLen = usageLen
1386 		}
1387 		commandPathLen := len(command.CommandPath())
1388 		if commandPathLen > c.commandsMaxCommandPathLen {
1389 			c.commandsMaxCommandPathLen = commandPathLen
1390 		}
1391 		nameLen := len(command.Name())
1392 		if nameLen > c.commandsMaxNameLen {
1393 			c.commandsMaxNameLen = nameLen
1394 		}
1395 	}
1396 }
1397 
1398 // Print is a convenience method to Print to the defined output, fallback to Stderr if not set.
1399 func (c *Command) Print(i ...interface{}) {
1400 	fmt.Fprint(c.OutOrStderr(), i...)
1401 }
1402 
1403 // Println is a convenience method to Println to the defined output, fallback to Stderr if not set.
1404 func (c *Command) Println(i ...interface{}) {
1405 	c.Print(fmt.Sprintln(i...))
1406 }
1407 
1408 // Printf is a convenience method to Printf to the defined output, fallback to Stderr if not set.
1409 func (c *Command) Printf(format string, i ...interface{}) {
1410 	c.Print(fmt.Sprintf(format, i...))
1411 }
1412 
1413 // PrintErr is a convenience method to Print to the defined Err output, fallback to Stderr if not set.
1414 func (c *Command) PrintErr(i ...interface{}) {
1415 	fmt.Fprint(c.ErrOrStderr(), i...)
1416 }
1417 
1418 // PrintErrln is a convenience method to Println to the defined Err output, fallback to Stderr if not set.
1419 func (c *Command) PrintErrln(i ...interface{}) {
1420 	c.PrintErr(fmt.Sprintln(i...))
1421 }
1422 
1423 // PrintErrf is a convenience method to Printf to the defined Err output, fallback to Stderr if not set.
1424 func (c *Command) PrintErrf(format string, i ...interface{}) {
1425 	c.PrintErr(fmt.Sprintf(format, i...))
1426 }
1427 
1428 // CommandPath returns the full path to this command.
1429 func (c *Command) CommandPath() string {
1430 	if c.HasParent() {
1431 		return c.Parent().CommandPath() + " " + c.Name()
1432 	}
1433 	return c.displayName()
1434 }
1435 
1436 func (c *Command) displayName() string {
1437 	if displayName, ok := c.Annotations[CommandDisplayNameAnnotation]; ok {
1438 		return displayName
1439 	}
1440 	return c.Name()
1441 }
1442 
1443 // UseLine puts out the full usage for a given command (including parents).
1444 func (c *Command) UseLine() string {
1445 	var useline string
1446 	use := strings.Replace(c.Use, c.Name(), c.displayName(), 1)
1447 	if c.HasParent() {
1448 		useline = c.parent.CommandPath() + " " + use
1449 	} else {
1450 		useline = use
1451 	}
1452 	if c.DisableFlagsInUseLine {
1453 		return useline
1454 	}
1455 	if c.HasAvailableFlags() && !strings.Contains(useline, "[flags]") {
1456 		useline += " [flags]"
1457 	}
1458 	return useline
1459 }
1460 
1461 // DebugFlags used to determine which flags have been assigned to which commands
1462 // and which persist.
1463 func (c *Command) DebugFlags() {
1464 	c.Println("DebugFlags called on", c.Name())
1465 	var debugflags func(*Command)
1466 
1467 	debugflags = func(x *Command) {
1468 		if x.HasFlags() || x.HasPersistentFlags() {
1469 			c.Println(x.Name())
1470 		}
1471 		if x.HasFlags() {
1472 			x.flags.VisitAll(func(f *flag.Flag) {
1473 				if x.HasPersistentFlags() && x.persistentFlag(f.Name) != nil {
1474 					c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [LP]")
1475 				} else {
1476 					c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [L]")
1477 				}
1478 			})
1479 		}
1480 		if x.HasPersistentFlags() {
1481 			x.pflags.VisitAll(func(f *flag.Flag) {
1482 				if x.HasFlags() {
1483 					if x.flags.Lookup(f.Name) == nil {
1484 						c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [P]")
1485 					}
1486 				} else {
1487 					c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [P]")
1488 				}
1489 			})
1490 		}
1491 		c.Println(x.flagErrorBuf)
1492 		if x.HasSubCommands() {
1493 			for _, y := range x.commands {
1494 				debugflags(y)
1495 			}
1496 		}
1497 	}
1498 
1499 	debugflags(c)
1500 }
1501 
1502 // Name returns the command's name: the first word in the use line.
1503 func (c *Command) Name() string {
1504 	name := c.Use
1505 	i := strings.Index(name, " ")
1506 	if i >= 0 {
1507 		name = name[:i]
1508 	}
1509 	return name
1510 }
1511 
1512 // HasAlias determines if a given string is an alias of the command.
1513 func (c *Command) HasAlias(s string) bool {
1514 	for _, a := range c.Aliases {
1515 		if commandNameMatches(a, s) {
1516 			return true
1517 		}
1518 	}
1519 	return false
1520 }
1521 
1522 // CalledAs returns the command name or alias that was used to invoke
1523 // this command or an empty string if the command has not been called.
1524 func (c *Command) CalledAs() string {
1525 	if c.commandCalledAs.called {
1526 		return c.commandCalledAs.name
1527 	}
1528 	return ""
1529 }
1530 
1531 // hasNameOrAliasPrefix returns true if the Name or any of aliases start
1532 // with prefix
1533 func (c *Command) hasNameOrAliasPrefix(prefix string) bool {
1534 	if strings.HasPrefix(c.Name(), prefix) {
1535 		c.commandCalledAs.name = c.Name()
1536 		return true
1537 	}
1538 	for _, alias := range c.Aliases {
1539 		if strings.HasPrefix(alias, prefix) {
1540 			c.commandCalledAs.name = alias
1541 			return true
1542 		}
1543 	}
1544 	return false
1545 }
1546 
1547 // NameAndAliases returns a list of the command name and all aliases
1548 func (c *Command) NameAndAliases() string {
1549 	return strings.Join(append([]string{c.Name()}, c.Aliases...), ", ")
1550 }
1551 
1552 // HasExample determines if the command has example.
1553 func (c *Command) HasExample() bool {
1554 	return len(c.Example) > 0
1555 }
1556 
1557 // Runnable determines if the command is itself runnable.
1558 func (c *Command) Runnable() bool {
1559 	return c.Run != nil || c.RunE != nil
1560 }
1561 
1562 // HasSubCommands determines if the command has children commands.
1563 func (c *Command) HasSubCommands() bool {
1564 	return len(c.commands) > 0
1565 }
1566 
1567 // IsAvailableCommand determines if a command is available as a non-help command
1568 // (this includes all non deprecated/hidden commands).
1569 func (c *Command) IsAvailableCommand() bool {
1570 	if len(c.Deprecated) != 0 || c.Hidden {
1571 		return false
1572 	}
1573 
1574 	if c.HasParent() && c.Parent().helpCommand == c {
1575 		return false
1576 	}
1577 
1578 	if c.Runnable() || c.HasAvailableSubCommands() {
1579 		return true
1580 	}
1581 
1582 	return false
1583 }
1584 
1585 // IsAdditionalHelpTopicCommand determines if a command is an additional
1586 // help topic command; additional help topic command is determined by the
1587 // fact that it is NOT runnable/hidden/deprecated, and has no sub commands that
1588 // are runnable/hidden/deprecated.
1589 // Concrete example: https://github.com/spf13/cobra/issues/393#issuecomment-282741924.
1590 func (c *Command) IsAdditionalHelpTopicCommand() bool {
1591 	// if a command is runnable, deprecated, or hidden it is not a 'help' command
1592 	if c.Runnable() || len(c.Deprecated) != 0 || c.Hidden {
1593 		return false
1594 	}
1595 
1596 	// if any non-help sub commands are found, the command is not a 'help' command
1597 	for _, sub := range c.commands {
1598 		if !sub.IsAdditionalHelpTopicCommand() {
1599 			return false
1600 		}
1601 	}
1602 
1603 	// the command either has no sub commands, or no non-help sub commands
1604 	return true
1605 }
1606 
1607 // HasHelpSubCommands determines if a command has any available 'help' sub commands
1608 // that need to be shown in the usage/help default template under 'additional help
1609 // topics'.
1610 func (c *Command) HasHelpSubCommands() bool {
1611 	// return true on the first found available 'help' sub command
1612 	for _, sub := range c.commands {
1613 		if sub.IsAdditionalHelpTopicCommand() {
1614 			return true
1615 		}
1616 	}
1617 
1618 	// the command either has no sub commands, or no available 'help' sub commands
1619 	return false
1620 }
1621 
1622 // HasAvailableSubCommands determines if a command has available sub commands that
1623 // need to be shown in the usage/help default template under 'available commands'.
1624 func (c *Command) HasAvailableSubCommands() bool {
1625 	// return true on the first found available (non deprecated/help/hidden)
1626 	// sub command
1627 	for _, sub := range c.commands {
1628 		if sub.IsAvailableCommand() {
1629 			return true
1630 		}
1631 	}
1632 
1633 	// the command either has no sub commands, or no available (non deprecated/help/hidden)
1634 	// sub commands
1635 	return false
1636 }
1637 
1638 // HasParent determines if the command is a child command.
1639 func (c *Command) HasParent() bool {
1640 	return c.parent != nil
1641 }
1642 
1643 // GlobalNormalizationFunc returns the global normalization function or nil if it doesn't exist.
1644 func (c *Command) GlobalNormalizationFunc() func(f *flag.FlagSet, name string) flag.NormalizedName {
1645 	return c.globNormFunc
1646 }
1647 
1648 // Flags returns the complete FlagSet that applies
1649 // to this command (local and persistent declared here and by all parents).
1650 func (c *Command) Flags() *flag.FlagSet {
1651 	if c.flags == nil {
1652 		c.flags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1653 		if c.flagErrorBuf == nil {
1654 			c.flagErrorBuf = new(bytes.Buffer)
1655 		}
1656 		c.flags.SetOutput(c.flagErrorBuf)
1657 	}
1658 
1659 	return c.flags
1660 }
1661 
1662 // LocalNonPersistentFlags are flags specific to this command which will NOT persist to subcommands.
1663 // This function does not modify the flags of the current command, it's purpose is to return the current state.
1664 func (c *Command) LocalNonPersistentFlags() *flag.FlagSet {
1665 	persistentFlags := c.PersistentFlags()
1666 
1667 	out := flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1668 	c.LocalFlags().VisitAll(func(f *flag.Flag) {
1669 		if persistentFlags.Lookup(f.Name) == nil {
1670 			out.AddFlag(f)
1671 		}
1672 	})
1673 	return out
1674 }
1675 
1676 // LocalFlags returns the local FlagSet specifically set in the current command.
1677 // This function does not modify the flags of the current command, it's purpose is to return the current state.
1678 func (c *Command) LocalFlags() *flag.FlagSet {
1679 	c.mergePersistentFlags()
1680 
1681 	if c.lflags == nil {
1682 		c.lflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1683 		if c.flagErrorBuf == nil {
1684 			c.flagErrorBuf = new(bytes.Buffer)
1685 		}
1686 		c.lflags.SetOutput(c.flagErrorBuf)
1687 	}
1688 	c.lflags.SortFlags = c.Flags().SortFlags
1689 	if c.globNormFunc != nil {
1690 		c.lflags.SetNormalizeFunc(c.globNormFunc)
1691 	}
1692 
1693 	addToLocal := func(f *flag.Flag) {
1694 		// Add the flag if it is not a parent PFlag, or it shadows a parent PFlag
1695 		if c.lflags.Lookup(f.Name) == nil && f != c.parentsPflags.Lookup(f.Name) {
1696 			c.lflags.AddFlag(f)
1697 		}
1698 	}
1699 	c.Flags().VisitAll(addToLocal)
1700 	c.PersistentFlags().VisitAll(addToLocal)
1701 	return c.lflags
1702 }
1703 
1704 // InheritedFlags returns all flags which were inherited from parent commands.
1705 // This function does not modify the flags of the current command, it's purpose is to return the current state.
1706 func (c *Command) InheritedFlags() *flag.FlagSet {
1707 	c.mergePersistentFlags()
1708 
1709 	if c.iflags == nil {
1710 		c.iflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1711 		if c.flagErrorBuf == nil {
1712 			c.flagErrorBuf = new(bytes.Buffer)
1713 		}
1714 		c.iflags.SetOutput(c.flagErrorBuf)
1715 	}
1716 
1717 	local := c.LocalFlags()
1718 	if c.globNormFunc != nil {
1719 		c.iflags.SetNormalizeFunc(c.globNormFunc)
1720 	}
1721 
1722 	c.parentsPflags.VisitAll(func(f *flag.Flag) {
1723 		if c.iflags.Lookup(f.Name) == nil && local.Lookup(f.Name) == nil {
1724 			c.iflags.AddFlag(f)
1725 		}
1726 	})
1727 	return c.iflags
1728 }
1729 
1730 // NonInheritedFlags returns all flags which were not inherited from parent commands.
1731 // This function does not modify the flags of the current command, it's purpose is to return the current state.
1732 func (c *Command) NonInheritedFlags() *flag.FlagSet {
1733 	return c.LocalFlags()
1734 }
1735 
1736 // PersistentFlags returns the persistent FlagSet specifically set in the current command.
1737 func (c *Command) PersistentFlags() *flag.FlagSet {
1738 	if c.pflags == nil {
1739 		c.pflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1740 		if c.flagErrorBuf == nil {
1741 			c.flagErrorBuf = new(bytes.Buffer)
1742 		}
1743 		c.pflags.SetOutput(c.flagErrorBuf)
1744 	}
1745 	return c.pflags
1746 }
1747 
1748 // ResetFlags deletes all flags from command.
1749 func (c *Command) ResetFlags() {
1750 	c.flagErrorBuf = new(bytes.Buffer)
1751 	c.flagErrorBuf.Reset()
1752 	c.flags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1753 	c.flags.SetOutput(c.flagErrorBuf)
1754 	c.pflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1755 	c.pflags.SetOutput(c.flagErrorBuf)
1756 
1757 	c.lflags = nil
1758 	c.iflags = nil
1759 	c.parentsPflags = nil
1760 }
1761 
1762 // HasFlags checks if the command contains any flags (local plus persistent from the entire structure).
1763 func (c *Command) HasFlags() bool {
1764 	return c.Flags().HasFlags()
1765 }
1766 
1767 // HasPersistentFlags checks if the command contains persistent flags.
1768 func (c *Command) HasPersistentFlags() bool {
1769 	return c.PersistentFlags().HasFlags()
1770 }
1771 
1772 // HasLocalFlags checks if the command has flags specifically declared locally.
1773 func (c *Command) HasLocalFlags() bool {
1774 	return c.LocalFlags().HasFlags()
1775 }
1776 
1777 // HasInheritedFlags checks if the command has flags inherited from its parent command.
1778 func (c *Command) HasInheritedFlags() bool {
1779 	return c.InheritedFlags().HasFlags()
1780 }
1781 
1782 // HasAvailableFlags checks if the command contains any flags (local plus persistent from the entire
1783 // structure) which are not hidden or deprecated.
1784 func (c *Command) HasAvailableFlags() bool {
1785 	return c.Flags().HasAvailableFlags()
1786 }
1787 
1788 // HasAvailablePersistentFlags checks if the command contains persistent flags which are not hidden or deprecated.
1789 func (c *Command) HasAvailablePersistentFlags() bool {
1790 	return c.PersistentFlags().HasAvailableFlags()
1791 }
1792 
1793 // HasAvailableLocalFlags checks if the command has flags specifically declared locally which are not hidden
1794 // or deprecated.
1795 func (c *Command) HasAvailableLocalFlags() bool {
1796 	return c.LocalFlags().HasAvailableFlags()
1797 }
1798 
1799 // HasAvailableInheritedFlags checks if the command has flags inherited from its parent command which are
1800 // not hidden or deprecated.
1801 func (c *Command) HasAvailableInheritedFlags() bool {
1802 	return c.InheritedFlags().HasAvailableFlags()
1803 }
1804 
1805 // Flag climbs up the command tree looking for matching flag.
1806 func (c *Command) Flag(name string) (flag *flag.Flag) {
1807 	flag = c.Flags().Lookup(name)
1808 
1809 	if flag == nil {
1810 		flag = c.persistentFlag(name)
1811 	}
1812 
1813 	return
1814 }
1815 
1816 // Recursively find matching persistent flag.
1817 func (c *Command) persistentFlag(name string) (flag *flag.Flag) {
1818 	if c.HasPersistentFlags() {
1819 		flag = c.PersistentFlags().Lookup(name)
1820 	}
1821 
1822 	if flag == nil {
1823 		c.updateParentsPflags()
1824 		flag = c.parentsPflags.Lookup(name)
1825 	}
1826 	return
1827 }
1828 
1829 // ParseFlags parses persistent flag tree and local flags.
1830 func (c *Command) ParseFlags(args []string) error {
1831 	if c.DisableFlagParsing {
1832 		return nil
1833 	}
1834 
1835 	if c.flagErrorBuf == nil {
1836 		c.flagErrorBuf = new(bytes.Buffer)
1837 	}
1838 	beforeErrorBufLen := c.flagErrorBuf.Len()
1839 	c.mergePersistentFlags()
1840 
1841 	// do it here after merging all flags and just before parse
1842 	c.Flags().ParseErrorsWhitelist = flag.ParseErrorsWhitelist(c.FParseErrWhitelist)
1843 
1844 	err := c.Flags().Parse(args)
1845 	// Print warnings if they occurred (e.g. deprecated flag messages).
1846 	if c.flagErrorBuf.Len()-beforeErrorBufLen > 0 && err == nil {
1847 		c.Print(c.flagErrorBuf.String())
1848 	}
1849 
1850 	return err
1851 }
1852 
1853 // Parent returns a commands parent command.
1854 func (c *Command) Parent() *Command {
1855 	return c.parent
1856 }
1857 
1858 // mergePersistentFlags merges c.PersistentFlags() to c.Flags()
1859 // and adds missing persistent flags of all parents.
1860 func (c *Command) mergePersistentFlags() {
1861 	c.updateParentsPflags()
1862 	c.Flags().AddFlagSet(c.PersistentFlags())
1863 	c.Flags().AddFlagSet(c.parentsPflags)
1864 }
1865 
1866 // updateParentsPflags updates c.parentsPflags by adding
1867 // new persistent flags of all parents.
1868 // If c.parentsPflags == nil, it makes new.
1869 func (c *Command) updateParentsPflags() {
1870 	if c.parentsPflags == nil {
1871 		c.parentsPflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
1872 		c.parentsPflags.SetOutput(c.flagErrorBuf)
1873 		c.parentsPflags.SortFlags = false
1874 	}
1875 
1876 	if c.globNormFunc != nil {
1877 		c.parentsPflags.SetNormalizeFunc(c.globNormFunc)
1878 	}
1879 
1880 	c.Root().PersistentFlags().AddFlagSet(flag.CommandLine)
1881 
1882 	c.VisitParents(func(parent *Command) {
1883 		c.parentsPflags.AddFlagSet(parent.PersistentFlags())
1884 	})
1885 }
1886 
1887 // commandNameMatches checks if two command names are equal
1888 // taking into account case sensitivity according to
1889 // EnableCaseInsensitive global configuration.
1890 func commandNameMatches(s string, t string) bool {
1891 	if EnableCaseInsensitive {
1892 		return strings.EqualFold(s, t)
1893 	}
1894 
1895 	return s == t
1896 }
1897 
======================================

FILE NAME : cobra.go =====
1 // Copyright 2013-2023 The Cobra Authors
2 //
3 // Licensed under the Apache License, Version 2.0 (the "License");
4 // you may not use this file except in compliance with the License.
5 // You may obtain a copy of the License at
6 //
7 //      http://www.apache.org/licenses/LICENSE-2.0
8 //
9 // Unless required by applicable law or agreed to in writing, software
10 // distributed under the License is distributed on an "AS IS" BASIS,
11 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12 // See the License for the specific language governing permissions and
13 // limitations under the License.
14 
15 // Commands similar to git, go tools and other modern CLI tools
16 // inspired by go, go-Commander, gh and subcommand
17 
18 package cobra
19 
20 import (
21 	"fmt"
22 	"io"
23 	"os"
24 	"reflect"
25 	"strconv"
26 	"strings"
27 	"text/template"
28 	"time"
29 	"unicode"
30 )
31 
32 var templateFuncs = template.FuncMap{
33 	"trim":                    strings.TrimSpace,
34 	"trimRightSpace":          trimRightSpace,
35 	"trimTrailingWhitespaces": trimRightSpace,
36 	"appendIfNotPresent":      appendIfNotPresent,
37 	"rpad":                    rpad,
38 	"gt":                      Gt,
39 	"eq":                      Eq,
40 }
41 
42 var initializers []func()
43 var finalizers []func()
44 
45 const (
46 	defaultPrefixMatching   = false
47 	defaultCommandSorting   = true
48 	defaultCaseInsensitive  = false
49 	defaultTraverseRunHooks = false
50 )
51 
52 // EnablePrefixMatching allows setting automatic prefix matching. Automatic prefix matching can be a dangerous thing
53 // to automatically enable in CLI tools.
54 // Set this to true to enable it.
55 var EnablePrefixMatching = defaultPrefixMatching
56 
57 // EnableCommandSorting controls sorting of the slice of commands, which is turned on by default.
58 // To disable sorting, set it to false.
59 var EnableCommandSorting = defaultCommandSorting
60 
61 // EnableCaseInsensitive allows case-insensitive commands names. (case sensitive by default)
62 var EnableCaseInsensitive = defaultCaseInsensitive
63 
64 // EnableTraverseRunHooks executes persistent pre-run and post-run hooks from all parents.
65 // By default this is disabled, which means only the first run hook to be found is executed.
66 var EnableTraverseRunHooks = defaultTraverseRunHooks
67 
68 // MousetrapHelpText enables an information splash screen on Windows
69 // if the CLI is started from explorer.exe.
70 // To disable the mousetrap, just set this variable to blank string ("").
71 // Works only on Microsoft Windows.
72 var MousetrapHelpText = `This is a command line tool.
73 
74 You need to open cmd.exe and run it from there.
75 `
76 
77 // MousetrapDisplayDuration controls how long the MousetrapHelpText message is displayed on Windows
78 // if the CLI is started from explorer.exe. Set to 0 to wait for the return key to be pressed.
79 // To disable the mousetrap, just set MousetrapHelpText to blank string ("").
80 // Works only on Microsoft Windows.
81 var MousetrapDisplayDuration = 5 * time.Second
82 
83 // AddTemplateFunc adds a template function that's available to Usage and Help
84 // template generation.
85 func AddTemplateFunc(name string, tmplFunc interface{}) {
86 	templateFuncs[name] = tmplFunc
87 }
88 
89 // AddTemplateFuncs adds multiple template functions that are available to Usage and
90 // Help template generation.
91 func AddTemplateFuncs(tmplFuncs template.FuncMap) {
92 	for k, v := range tmplFuncs {
93 		templateFuncs[k] = v
94 	}
95 }
96 
97 // OnInitialize sets the passed functions to be run when each command's
98 // Execute method is called.
99 func OnInitialize(y ...func()) {
100 	initializers = append(initializers, y...)
101 }
102 
103 // OnFinalize sets the passed functions to be run when each command's
104 // Execute method is terminated.
105 func OnFinalize(y ...func()) {
106 	finalizers = append(finalizers, y...)
107 }
108 
109 // FIXME Gt is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.
110 
111 // Gt takes two types and checks whether the first type is greater than the second. In case of types Arrays, Chans,
112 // Maps and Slices, Gt will compare their lengths. Ints are compared directly while strings are first parsed as
113 // ints and then compared.
114 func Gt(a interface{}, b interface{}) bool {
115 	var left, right int64
116 	av := reflect.ValueOf(a)
117 
118 	switch av.Kind() {
119 	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
120 		left = int64(av.Len())
121 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
122 		left = av.Int()
123 	case reflect.String:
124 		left, _ = strconv.ParseInt(av.String(), 10, 64)
125 	}
126 
127 	bv := reflect.ValueOf(b)
128 
129 	switch bv.Kind() {
130 	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
131 		right = int64(bv.Len())
132 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
133 		right = bv.Int()
134 	case reflect.String:
135 		right, _ = strconv.ParseInt(bv.String(), 10, 64)
136 	}
137 
138 	return left > right
139 }
140 
141 // FIXME Eq is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.
142 
143 // Eq takes two types and checks whether they are equal. Supported types are int and string. Unsupported types will panic.
144 func Eq(a interface{}, b interface{}) bool {
145 	av := reflect.ValueOf(a)
146 	bv := reflect.ValueOf(b)
147 
148 	switch av.Kind() {
149 	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
150 		panic("Eq called on unsupported type")
151 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
152 		return av.Int() == bv.Int()
153 	case reflect.String:
154 		return av.String() == bv.String()
155 	}
156 	return false
157 }
158 
159 func trimRightSpace(s string) string {
160 	return strings.TrimRightFunc(s, unicode.IsSpace)
161 }
162 
163 // FIXME appendIfNotPresent is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.
164 
165 // appendIfNotPresent will append stringToAppend to the end of s, but only if it's not yet present in s.
166 func appendIfNotPresent(s, stringToAppend string) string {
167 	if strings.Contains(s, stringToAppend) {
168 		return s
169 	}
170 	return s + " " + stringToAppend
171 }
172 
173 // rpad adds padding to the right of a string.
174 func rpad(s string, padding int) string {
175 	formattedString := fmt.Sprintf("%%-%ds", padding)
176 	return fmt.Sprintf(formattedString, s)
177 }
178 
179 // tmpl executes the given template text on data, writing the result to w.
180 func tmpl(w io.Writer, text string, data interface{}) error {
181 	t := template.New("top")
182 	t.Funcs(templateFuncs)
183 	template.Must(t.Parse(text))
184 	return t.Execute(w, data)
185 }
186 
187 // ld compares two strings and returns the levenshtein distance between them.
188 func ld(s, t string, ignoreCase bool) int {
189 	if ignoreCase {
190 		s = strings.ToLower(s)
191 		t = strings.ToLower(t)
192 	}
193 	d := make([][]int, len(s)+1)
194 	for i := range d {
195 		d[i] = make([]int, len(t)+1)
196 		d[i][0] = i
197 	}
198 	for j := range d[0] {
199 		d[0][j] = j
200 	}
201 	for j := 1; j <= len(t); j++ {
202 		for i := 1; i <= len(s); i++ {
203 			if s[i-1] == t[j-1] {
204 				d[i][j] = d[i-1][j-1]
205 			} else {
206 				min := d[i-1][j]
207 				if d[i][j-1] < min {
208 					min = d[i][j-1]
209 				}
210 				if d[i-1][j-1] < min {
211 					min = d[i-1][j-1]
212 				}
213 				d[i][j] = min + 1
214 			}
215 		}
216 
217 	}
218 	return d[len(s)][len(t)]
219 }
220 
221 func stringInSlice(a string, list []string) bool {
222 	for _, b := range list {
223 		if b == a {
224 			return true
225 		}
226 	}
227 	return false
228 }
229 
230 // CheckErr prints the msg with the prefix 'Error:' and exits with error code 1. If the msg is nil, it does nothing.
231 func CheckErr(msg interface{}) {
232 	if msg != nil {
233 		fmt.Fprintln(os.Stderr, "Error:", msg)
234 		os.Exit(1)
235 	}
236 }
237 
238 // WriteStringAndCheck writes a string into a buffer, and checks if the error is not nil.
239 func WriteStringAndCheck(b io.StringWriter, s string) {
240 	_, err := b.WriteString(s)
241 	CheckErr(err)
242 }
243 
======================================
